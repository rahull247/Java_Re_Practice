package com.practice.demo.practice;


import org.junit.jupiter.api.Test;

import java.util.*;
import java.util.function.Function;
import java.util.stream.Collectors;
import java.util.stream.IntStream;
import java.util.stream.Stream;

public class JavaStreamProgram {
    @Test
    public void firstTest() {
        List<String> list = Arrays.asList("a", "b", "a", "c", "a", "d");
        List<String> result = list.stream().filter(str -> str.startsWith("a"))
                .map(str -> str.toUpperCase())
                .collect(Collectors.toList());
        System.out.println(result);
    }

    @Test
    public void secondTest() {
        List<Users> stringList = Arrays.asList
                (new Users(1, "Rahul", 27),
                        new Users(2, "Akshay", 28),
                        new Users(3, "Ganesh", 32),
                        new Users(4, "Akash", 24),
                        new Users(5, "Aman", 21));

        List<String> result = stringList.stream().filter(user -> user.getName().startsWith("A"))
                .map(user -> user.getName().toUpperCase()).collect(Collectors.toList());
        System.out.println(result);
    }

    @Test
    public void distinctTest() {
        List<Users> stringList = Arrays.asList
                (new Users(1, "Rahul", 27),
                        new Users(2, "Akshay", 28),
                        new Users(3, "Ganesh", 32),
                        new Users(4, "Akash", 24),
                        new Users(5, "Aman", 21),
                        new Users(6, "Aman", 45));

        List<String> result = stringList.stream().filter(user -> user.getName().startsWith("A"))
                .map(user -> user.getName().toUpperCase()).distinct().collect(Collectors.toList());
        System.out.println(result);
    }

    @Test
    public void countTest() {
        List<Users> stringList = Arrays.asList
                (new Users(1, "Rahul", 27),
                        new Users(2, "Akshay", 28),
                        new Users(3, "Ganesh", 32),
                        new Users(4, "Akash", 24),
                        new Users(5, "Aman", 21),
                        new Users(6, "Aman", 45));

        long result = stringList.stream().filter(user -> user.getName().startsWith("A"))
                .count();
        System.out.println(result);
    }

    @Test
    public void ListToMapTest() {
        List<Users> stringList = Arrays.asList
                (new Users(1, "Rahul", 27),
                        new Users(2, "Akshay", 28),
                        new Users(3, "Ganesh", 32),
                        new Users(4, "Akash", 24),
                        new Users(5, "Aman", 21),
                        new Users(6, "Aman", 45));

        Map<Integer, String> result = stringList.stream().collect(Collectors.toMap(users -> users.getId(), users -> users.getName()));

        System.out.println(result);
    }

    @Test
    void findAnyTest() {
        List<String> stringList = Arrays.asList("Abc", "gdks", "hgk", "yuty", "gtde");
        Optional<String> result = stringList.stream()
                .filter(str -> str.length() > 3)
                .findAny();
        System.out.println(result);
    }

    @Test
    void flatMapTest1() {
        List<String> stringList = Arrays.asList("lambda", "In", "Action");
        List<String> result = stringList.stream()
                .map(str -> str.split(""))
                .flatMap(Arrays::stream)
                .collect(Collectors.toList());
        System.out.println(result);
    }

    @Test
    void flatMapTest2() {
        Map<String, List<String>> people = new HashMap<>();
        people.put("Chandan", Arrays.asList("12345", "36234"));
        people.put("Kartik", Arrays.asList("9013498119", "99883345"));
        people.put("Abhijeet", Arrays.asList("8963498119", "9988334576", "123985499"));

        List<String> result = people.values()
                .stream().
                flatMap(List::stream).
                collect(Collectors.toList());
        System.out.println(result);
    }

    @Test
    void limitFlatMapTest3() {
        Map<String, List<String>> people = new HashMap<>();
        people.put("Chandan", Arrays.asList("12345", "36234"));
        people.put("Kartik", Arrays.asList("9013498119", "99883345"));
        people.put("Abhijeet", Arrays.asList("8963498119", "9988334576", "123985499"));

        List<String> result = people.values()
                .stream().
                flatMap(List::stream)
                .limit(2)
                .collect(Collectors.toList());
        System.out.println(result);
    }

    @Test
    void skipFlatMapTest4() {
        Map<String, List<String>> people = new HashMap<>();
        people.put("Chandan", Arrays.asList("12345", "36234"));
        people.put("Kartik", Arrays.asList("9013498119", "99883345"));
        people.put("Abhijeet", Arrays.asList("8963498119", "9988334576", "123985499"));

        List<String> result = people.values()
                .stream().
                flatMap(List::stream)
                .limit(2)
                .skip(1)
                .collect(Collectors.toList());
        System.out.println(result);
    }

    @Test
    void anyMatchFlatMapTest4() {
        Map<String, List<String>> people = new HashMap<>();
        people.put("Chandan", Arrays.asList("12345", "36234"));
        people.put("Kartik", Arrays.asList("9013498119", "99883345"));
        people.put("Abhijeet", Arrays.asList("8963498119", "9988334576", "123985499"));

        boolean result = people.values()
                .stream()
                .peek(s -> System.out.println(s))
                .flatMap(List::stream)
                .peek(s -> System.out.println("Hi" + s))
                .anyMatch(str -> str.length() > 3);

        System.out.println(result);
    }

    @Test
    void allMatchFlatMapTest4() {
        Map<String, List<String>> people = new HashMap<>();
        people.put("Chandan", Arrays.asList("12345", "36234"));
        people.put("Kartik", Arrays.asList("9013498119", "99883345"));
        people.put("Abhijeet", Arrays.asList("8963498119", "9988334576", "123985499"));

        boolean result = people.values()
                .stream()
                .flatMap(List::stream)
                .allMatch(str -> str.length() > 3);

        System.out.println(result);
    }

    @Test
    void seven_noneMatch() {
        List<String> stringList = Arrays.asList("lambda", "In", "Action");
        Stream<String> stream = stringList.stream();
        boolean b = stream.noneMatch(s -> s.length() > 5);
        System.out.println("Result " + b);
    }


    @Test
    void userMarksSortedWithName() {
        Stream<UserMarks> userMarksStream = Stream.of(
                new UserMarks("Rahul", 21, 81, 99),
                new UserMarks("Akshay", 27, 95, 81),
                new UserMarks("Simon", 25, 73, 77),
                new UserMarks("Kunal", 23, 50, 100)
        );

        List<UserMarks> result = userMarksStream.sorted(Comparator.comparing(UserMarks::getName)).collect(Collectors.toList());
        System.out.println(result);
    }

    @Test
    void userMarksSortedWithAge() {
        Stream<UserMarks> userMarksStream = Stream.of(
                new UserMarks("Rahul", 21, 81, 99),
                new UserMarks("Akshay", 27, 95, 81),
                new UserMarks("Simon", 25, 73, 77),
                new UserMarks("Kunal", 23, 50, 100)
        );

        List<UserMarks> result = userMarksStream.sorted(Comparator.comparing(UserMarks::getAge)).collect(Collectors.toList());
        System.out.println(result);
    }

    @Test
    void userMarksSortedWithNameOnly() {
        Stream<UserMarks> userMarksStream = Stream.of(
                new UserMarks("Rahul", 21, 81, 99),
                new UserMarks("Akshay", 27, 95, 81),
                new UserMarks("Simon", 25, 73, 77),
                new UserMarks("Kunal", 23, 50, 100)
        );

        List<String> result = userMarksStream.sorted(Comparator.comparing(UserMarks::getName))
                .map(userMarks -> userMarks.getName())
                .collect(Collectors.toList());
        System.out.println(result);
    }

    @Test
    void userMarksSortedWithAgeOnly() {
        Stream<UserMarks> userMarksStream = Stream.of(
                new UserMarks("Rahul", 21, 81, 99),
                new UserMarks("Akshay", 27, 95, 81),
                new UserMarks("Simon", 25, 73, 77),
                new UserMarks("Kunal", 23, 50, 100)
        );

        Stream<Integer> result =
                userMarksStream.map(userMarks -> userMarks.getAge())
                        .sorted();
        result.forEach(System.out::println);
    }

    @Test
    void userMarksMathSumOnly() {
        Stream<UserMarks> userMarksStream = Stream.of(
                new UserMarks("Rahul", 21, 81, 99),
                new UserMarks("Akshay", 27, 95, 81),
                new UserMarks("Simon", 25, 73, 77),
                new UserMarks("Kunal", 23, 50, 100)
        );

        int result =
                userMarksStream.mapToInt(UserMarks::getMathsMarks).sum();
        System.out.println(result);
    }

    @Test
    void userMarksScienceSumOnly() {
        Stream<UserMarks> userMarksStream = Stream.of(
                new UserMarks("Rahul", 21, 81, 99),
                new UserMarks("Akshay", 27, 95, 81),
                new UserMarks("Simon", 25, 73, 77),
                new UserMarks("Kunal", 23, 50, 100)
        );

        int result =
                userMarksStream.mapToInt(UserMarks::getScienceMarks).sum();
        System.out.println(result);
    }

    @Test
    void userMarksnumberSumOnly() {
        Stream<Integer> userMarksStream = Stream.of(1, 2, 3, 4, 5);

        int result =
                userMarksStream.mapToInt(i -> i).sum();
        System.out.println(result);
    }

    @Test
    void userMarksMathMin() {
        Stream<UserMarks> userMarksStream = Stream.of(
                new UserMarks("Rahul", 21, 81, 99),
                new UserMarks("Akshay", 27, 95, 81),
                new UserMarks("Simon", 25, 73, 77),
                new UserMarks("Kunal", 23, 50, 100)
        );

        OptionalInt result =
                userMarksStream.mapToInt(UserMarks::getMathsMarks).min();
        System.out.println(result);
    }

    @Test
    void userMarksScienceMax() {
        Stream<UserMarks> userMarksStream = Stream.of(
                new UserMarks("Rahul", 21, 81, 99),
                new UserMarks("Akshay", 27, 95, 81),
                new UserMarks("Simon", 25, 73, 77),
                new UserMarks("Kunal", 23, 50, 100)
        );

        OptionalInt result =
                userMarksStream.mapToInt(UserMarks::getScienceMarks).max();
        System.out.println(result);
    }

    @Test
    void userMarksPersonWithScienceMaxMarks() {
        Stream<UserMarks> userMarksStream = Stream.of(
                new UserMarks("Rahul", 21, 81, 99),
                new UserMarks("Akshay", 27, 95, 81),
                new UserMarks("Simon", 25, 73, 77),
                new UserMarks("Kunal", 23, 50, 100)
        );

        Optional<String> result =
                userMarksStream.max(Comparator.comparing(UserMarks::getScienceMarks)).map(UserMarks::getName);
        System.out.println(result);
    }

    @Test
    void userMarksPersonWithScienceMinMarks() {
        Stream<UserMarks> userMarksStream = Stream.of(
                new UserMarks("Rahul", 21, 81, 99),
                new UserMarks("Akshay", 27, 95, 81),
                new UserMarks("Simon", 25, 73, 77),
                new UserMarks("Kunal", 23, 50, 100)
        );

        Optional<String> result =
                userMarksStream.min(Comparator.comparing(UserMarks::getMathsMarks)).map(UserMarks::getName);
        System.out.println(result);
    }

    @Test
    void userMarksPersonWithMaxMarksInOverall() {
        Stream<UserMarks> userMarksStream = Stream.of(
                new UserMarks("Rahul", 21, 81, 99),
                new UserMarks("Akshay", 27, 95, 81),
                new UserMarks("Simon", 25, 73, 77),
                new UserMarks("Kunal", 23, 50, 100)
        );

       /*Optional<String> result=
               userMarksStream.max(Comparator.comparing(user->user.getScienceMarks() + user.getMathsMarks())).map(UserMarks::getName);*/
        String result = userMarksStream.max(Comparator.comparing(user -> user.getMathsMarks() + user.getScienceMarks())).get().getName();
        System.out.println(result);
    }

    @Test
    void userMarksPersonWithYoungest() {
        Stream<UserMarks> userMarksStream = Stream.of(
                new UserMarks("Rahul", 21, 81, 99),
                new UserMarks("Akshay", 27, 95, 81),
                new UserMarks("Simon", 25, 73, 77),
                new UserMarks("Kunal", 23, 50, 100)
        );

        Optional<String> result =
                userMarksStream.min(Comparator.comparing(UserMarks::getAge)).map(UserMarks::getName);
        System.out.println(result);
    }

    @Test
    void userMarksPersonWithYoungest1() {
        Stream<UserMarks> userMarksStream = Stream.of(
                new UserMarks("Rahul", 21, 81, 99),
                new UserMarks("Akshay", 27, 95, 81),
                new UserMarks("Simon", 25, 73, 77),
                new UserMarks("Kunal", 23, 50, 100)
        );

        Optional<String> result =
                userMarksStream.min(Comparator.comparing(UserMarks::getAge)).map(UserMarks::getName);
        System.out.println(result);
    }

    @Test
    void userMarksPersonWithHighestMarksInMath() {
        Stream<UserMarks> userMarksStream = Stream.of(
                new UserMarks("Rahul", 21, 81, 99),
                new UserMarks("Akshay", 27, 95, 81),
                new UserMarks("Simon", 25, 73, 77),
                new UserMarks("Kunal", 23, 50, 100)
        );

        OptionalInt result =
                userMarksStream.mapToInt(UserMarks::getMathsMarks).max();
        System.out.println(result);
    }

    @Test
    void userMarksPersonWithHighestMarksInScience() {
        Stream<UserMarks> userMarksStream = Stream.of(
                new UserMarks("Rahul", 21, 81, 99),
                new UserMarks("Akshay", 27, 95, 81),
                new UserMarks("Simon", 25, 73, 77),
                new UserMarks("Kunal", 23, 50, 100)
        );

        OptionalInt result =
                userMarksStream.mapToInt(UserMarks::getScienceMarks).max();
        System.out.println(result);
    }

    @Test
    void userMarksPersonWithHighestMarks() {
        Stream<UserMarks> userMarksStream = Stream.of(
                new UserMarks("Rahul", 21, 81, 99),
                new UserMarks("Akshay", 27, 95, 81),
                new UserMarks("Simon", 25, 73, 77),
                new UserMarks("Kunal", 23, 50, 100)
        );

        String result =
                userMarksStream.max(Comparator.comparing(UserMarks::getMathsMarks)).get().getName();
        System.out.println(result);
    }

    @Test
    void secondTablePrint() {
        IntStream.rangeClosed(1, 10)
                .map(i -> i * 2).forEach(System.out::println);
    }

    @Test
    void aggregationCollector() {
        List<String> names = Arrays.asList("John", "Alice", "Bob", "Jane", "Jane");
        Map<Integer, Long> countByNameLength = names
                .stream()
                .collect(Collectors.groupingBy(String::length, Collectors.counting()));
        System.out.println(countByNameLength);

        Map<String, Long> countByNameLength1 = names.stream().map(s -> s.split("")).flatMap(Arrays::stream).collect(Collectors.groupingBy(s -> s, Collectors.counting()));
        System.out.println(countByNameLength1);

        Map<String, Long> collect = names.stream().collect(Collectors.groupingBy(s -> s, Collectors.counting()));
        System.out.println(collect);
    }

    @Test
    void productOfAllNumber() {
        //multiplication of all number
        List<Integer> numbers = List.of(1, 2, 3, 4, 5);
        int product = numbers.stream().reduce(1, (a, b) -> a * b);
        System.out.println("Product: " + product);
    }

    @Test
    void maxNUmber() {
        List<Integer> numbers = List.of(1, 2, 3, 4, 5);
        Optional<Integer> max = numbers.stream().max(Integer::compare);
        System.out.println("Max: " + max);

        OptionalInt max1 = numbers.stream().mapToInt(i -> i).max();
        System.out.println(max1);
    }

    @Test
    void reverseOrder() {
        List<Integer> numbers = List.of(5, 3, 1, 4, 2);
        List<Integer> sortedNumbers = numbers.stream()
                //.sorted((a, b)-> b-a)
                .sorted(Comparator.reverseOrder())
                .collect(Collectors.toList());
        System.out.println("Sorted Numbers (Descending): " + sortedNumbers);
    }

    @Test
    void sortByTheirLength() {
        List<String> words = List.of("apple", "banana", "kiwi");
        List<String> collect = words.stream().sorted(Comparator.comparing(String::length)).collect(Collectors.toList());
        System.out.println(collect);
    }

    @Test
    void findSumOfInteger() {
        int number = 12345;
        int sum = String.valueOf(number).chars()
                .map(Character::getNumericValue)
                .sum();
        System.out.println(sum);
    }

    @Test
    void findSecondLargestNum() {
        List<Integer> numbers = List.of(1, 2, 3, 4, 5);
        Optional<Integer> max = numbers.stream().sorted(Comparator.reverseOrder()).skip(1).findAny();
        System.out.println(max);
    }

    @Test
    void findSecondsmallestNum() {
        List<Integer> numbers = List.of(1, 2, 3, 4, 5);
        Optional<Integer> max = numbers.stream().sorted().skip(1).findAny();
        System.out.println(max);

        List<Integer> numbers1 = List.of(2, 1, 3, 5, 4);
        List<Integer> collect = numbers1.stream().sorted(Comparator.reverseOrder()).collect(Collectors.toList());
        System.out.println(collect);
    }

    @Test
    void findStringByTheirLength() {
        List<String> words = List.of("apple", "banana", "kiwi");
        Map<Integer, List<String>> collect = words.stream().collect(Collectors.groupingBy(String::length));
        System.out.println(collect);
    }

    @Test
    void partionedByEvenAndOdd() {
        List<Integer> numbers = List.of(1, 2, 3, 4, 5);
        Map<Boolean, List<Integer>> collect = numbers.stream().collect(Collectors.partitioningBy(n -> n % 2 == 0));
        System.out.println(collect);
    }

    @Test
    void countOfString() {
        String str = "hello rahul";
        Map<Character, Long> collect = str.chars().mapToObj(c -> (char) c).collect(Collectors.groupingBy(c -> c, Collectors.counting()));
        System.out.println(collect);

    }

    @Test
    void countOfStringWord() {
        String str = "hello rahul hello";
        Map<String, Long> collect = Arrays.stream(str.split(" ")).collect(Collectors.groupingBy(s -> s, Collectors.counting()));
        Map<Integer, Long> collect1 = Arrays.stream(str.split(" ")).collect(Collectors.groupingBy(String::length, Collectors.counting()));
        System.out.println(collect);
        System.out.println(collect1);
    }

    @Test
    void countOccuranceOfVowels() {
        String str = "hello rahula";
        Map<Character, Long> collect = str.chars().mapToObj(c -> (char) c)
                .filter(s -> "aeiou".contains(String.valueOf(s)))
                .collect(Collectors.groupingBy(s -> s, Collectors.counting()));
        System.out.println(collect);
    }

    @Test
    void countOccuranceOfDigit() {
        String str = "hello 123 rahul 1456";
        Map<Character, Long> collect = str.chars().mapToObj(c -> (char) c)
                .filter(Character::isDigit)
                .collect(Collectors.groupingBy(c -> c, Collectors.counting()));
        System.out.println(collect);
    }

    @Test
    void reverseTheList() {
        List<Integer> numbers = List.of(1, 2, 3, 4, 6, 5);
        List<Integer> collect = numbers.stream().collect(Collectors.collectingAndThen(Collectors.toList(), list -> {
            Collections.reverse(list);
            return list;
        }));
        System.out.println(collect);
    }

    @Test
    void mostFrequentElement() {
        List<String> words = List.of("apple", "banana", "apple", "orange", "banana", "apple");
        String result = words.stream()
                .collect(Collectors.groupingBy(s -> s, Collectors.counting()))
                .entrySet().stream().max(Map.Entry.comparingByValue()).map(Map.Entry::getKey).orElseGet(null);
        System.out.println(result);
    }

    @Test
    void leastFrequentElement() {
        List<String> words = List.of("apple", "banana", "apple", "orange", "banana", "apple");
        String result = words.stream()
                .collect(Collectors.groupingBy(s -> s, Collectors.counting()))
                .entrySet().stream().min(Map.Entry.comparingByValue()).map(Map.Entry::getKey).orElseGet(null);
        System.out.println(result);
    }

    @Test
    void findTheFirstNonRepeatedCharacter() {
        String input = "hello";

        IntStream chars = input.chars();
        Optional<Character> first = chars.mapToObj(c -> (char) c)
                .collect(Collectors.groupingBy(c -> c, LinkedHashMap::new, Collectors.counting()))
                .entrySet().stream().filter(entry -> entry.getValue() == 1)
                .map(Map.Entry::getKey)
                .findFirst();
        System.out.println("result" + first);

    }

    @Test
    void findTheFirstRepeatedCharacter() {
        String input = "hello";

        IntStream chars = input.chars();
        Stream<Character> characterStream = chars.mapToObj(c -> (char) c);
        System.out.println("characterStream" + characterStream);
        LinkedHashMap<Character, Long> collect = characterStream.collect(Collectors.groupingBy(c -> c, LinkedHashMap::new, Collectors.counting()));
        System.out.println("collect" + collect);
        Stream<Map.Entry<Character, Long>> entryStream =
                collect.entrySet().stream().filter(entry -> entry.getValue() > 1);
        System.out.println("entryStream" + entryStream);
        Stream<Character> characterStream1 = entryStream.map(Map.Entry::getKey);
        System.out.println("characterStream1" + characterStream1);
        Optional<Character> first = characterStream1.findFirst();
        System.out.println("result" + first);

    }

    @Test
    void checkStringIsPalindromeOrNot() {
        String input = "madam";
        IntStream intStream = IntStream.rangeClosed(0, input.length() / 2);
        boolean b = intStream.allMatch(i -> input.charAt(i) == input.charAt(input.length() - 1 - i));
        System.out.println(b);
    }

    @Test
    void generateRandomNumbers() {
        List<Integer> collect = Stream.generate(() -> new Random().nextInt(100))
                .limit(10)
                .collect(Collectors.toList());
        System.out.println(collect);
    }

    @Test
    void flattenList() {
        List<List<Integer>> lists = List.of(List.of(1, 2, 3),
                List.of(4, 5, 6),
                List.of(7, 8, 9));

        List<Integer> collect = lists.stream().flatMap(List::stream).collect(Collectors.toList());
        System.out.println(collect);


    }

    @Test
    void findSumOfEvenNumber() {
        List<List<Integer>> lists = List.of(List.of(1, 2, 3),
                List.of(4, 5, 6),
                List.of(7, 8, 9));

        int sum = lists.stream().flatMap(List::stream).filter(i -> i % 2 == 0).mapToInt(i -> i).sum();
        System.out.println(sum);


    }

    @Test
    void findLongestPalindromeInListOfString() {
        List<String> words = List.of("madam", "racecar", "apple", "banana", "level");
        Optional<String> max = words.stream().filter(str -> str.equals(new StringBuffer(str).reverse().toString()))
                .max(Comparator.comparing(String::length));
        //.max(Comparator.comparingInt(String::length));
        System.out.println(max);
    }

    @Test
    void reverString(){
        String input = "hello world this is a test";
        String reversed = input.chars()
                .mapToObj(c -> String.valueOf((char) c))
                .reduce("", (a, b) -> b + a);
        System.out.println(reversed);

        String input1 = "hello world this is a test";
        String output = Arrays.stream(input1.split(" "))
                .collect(Collectors.collectingAndThen(Collectors.toList(), list -> {
                    Collections.reverse(list);
                    return String.join(" ", list);
                }));
        System.out.println(output); // Output: test a is this world hello
    }
    @Test
    void findLongestString() {
        String input = "hello world this is a test";
        Optional<String> max = Arrays.stream(input.split(" "))
                .max(Comparator.comparingInt(String::length));
        System.out.println(max);
    }

    /*Java 8 stream program
    Input:
            ["eat", "tea", "tan", "ate", "nat", "bat"]

    Output:
    {
        "aet" -> ["eat", "tea", "ate"],
        "ant" -> ["tan", "nat"],
        "abt" -> ["bat"]
    }*/
    @Test
    void aboveProgram() {
        List<String> words = Arrays.asList("eat", "tea", "tan", "ate", "nat", "bat");

        Map<String, List<String>> grouped = words.stream()
                .collect(Collectors.groupingBy(
                        word -> {
                            char[] chars = word.toCharArray();
                            Arrays.sort(chars);
                            return new String(chars);
                        }
                ));

        System.out.println(grouped);
    }
    /*Java 8 program first Occurance

    input:
            ["apple", "ant", "banana", "ball", "bat", "umbrealla", "orange", "owl"]

    Output:
    {a="apple", b="banana", u="umbrella", o="orange"}*/

    @Test
    void aboveProgram1(){
        List<String> words = Arrays.asList("apple", "ant", "banana", "ball", "bat", "umbrealla", "orange", "owl");

        Map<String, String> firstOccurrence = words.stream()
                .collect(Collectors.toMap(
                        word -> word.substring(0, 1),
                        word -> word,
                        (existing, replacement) -> existing
                ));

        System.out.println(firstOccurrence);

    }

    @Test
    void distinctArraySum(){
        List<Integer> list1 = List.of(1, 2, 3);
        List<Integer> list2 = List.of(1, 1, 1);
        int sum = Stream.concat(list1.stream(), list2.stream()).distinct().mapToInt(Integer::intValue).sum();
        System.out.println(sum);
    }


    @Test
    void functionIdentity() {
        String str = "Hello";
        Map<Character, Long> collect = str.toLowerCase().chars().mapToObj(c -> (char) c).collect(Collectors.groupingBy(Function.identity(), Collectors.counting()));
        System.out.println(collect);
    }

}
